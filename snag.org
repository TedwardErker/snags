#+TITLE:Classify Snags
#+AUTHOR: Tedward Erker
#+email: erker@wisc.edu
##+PROPERTY: header-args:R :session *R:snag:krusty* :cache no :results output :exports results :tangle yes :eval yes
#+PROPERTY: header-args:R :session *R:snag:nhal* :cache no :results output :exports results :tangle yes :eval yes
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{natbib}
#+latex_header: \hypersetup{colorlinks=true,linkcolor=black, citecolor=black, urlcolor=black}
#+OPTIONS: toc:t h:5
------------

* hours
| in                     | out                    | hours |                  |                                                      |
|------------------------+------------------------+-------+------------------+------------------------------------------------------|
|                        |                        |    40 | previously       |                                                      |
| [2018-09-20 Thu 10:30] | [2018-09-20 Thu 11:20] |  .875 |                  |                                                      |
| [2018-09-21 Fri 10:00] | [2018-09-21 Fri 11:00] |     1 |                  |                                                      |
| [2018-09-25 Tue 9:30]  | [2018-09-25 Tue 10:30] |     1 |                  |                                                      |
| [2018-09-27 Thu 9:00]  | [2018-09-27 Thu 10:00] |     1 |                  |                                                      |
| [2018-09-28 Fri 9:00]  | [2018-09-28 Fri 12:00] |     3 |                  |                                                      |
| [2018-10-02 Tue 10:00] | [2018-10-02 Tue 11:00] |     1 |                  |                                                      |
| [2018-10-03 Wed 10:00] | [2018-10-03 Wed 14:00] |     4 |                  |                                                      |
| [2018-10-04 Thu 8:30]  | [2018-10-04 Thu 11:30] |     3 |                  |                                                      |
|                        |                        |       | [2018-10-22 Mon] | I submitted 40 hours for the 10/4 - 10/26 pay period |
| [2018-10-22 Mon 16:30] | [2018-10-22 Mon 17:00] |       |                  |                                                      |
| [2018-12-18 Tue 11:00] | [2018-12-18 Tue 14:00] |       |                  |                                                      |
| [2018-12-20 Thu 9:00]  | [2018-12-20 Thu 15:00] |       |                  |                                                      |
| [2018-12-21 Fri 9:20]  | [2018-12-21 Fri 13:00] |       |                  |                                                      |
| [2019-01-04 Fri 12:00] | [2019-01-04 Fri ]      |       |                  |                                                      |

* libraries
#+begin_src R
library(raster)
library(stringr)
library(glcm)
library(ff)
  library(dplyr)
library(randomForest)
  library(parallel)
    library(doParallel)
#+end_src

#+RESULTS:

* bits
** texture params
#+begin_src R
  band.for.texture.appendage = "_ratio.nir"
  window <- list(c(5,5), c(7,7), c(13,13))
  statistics = list("homogeneity", "contrast", "correlation", "entropy")
  shift = list(c(0,1),c(1,0),c(1,1),c(-1,1))
  texture.params <- expand.grid(band.appendage = band.for.texture.appendage,window = window, statistics = statistics, shift = shift, stringsAsFactors = F)
#+end_src

#+RESULTS:

* functions
** Feature Data Frame Related: texture, pca, segmentation, etc.
*** Save each band
#+begin_src R
  save_each_band <- function(tile.path, band.names) {
      tile <- stack(tile.path)
      names(tile) <- band.names
      tile.name <- str_sub(basename(tile.path),1,-5)
      writeRaster(tile, filename = paste0(dirname(tile.path),"/",tile.name,"_",names(tile), ".tif"), bylayer = T, format = "GTiff", overwrite = T)
  }

#+end_src

#+results:
*** Add Texture
#+begin_src R
  trunc.rescale.0.254 <- function(raster,
                            min,
                            max) {
      raster[raster < min] <- min
      raster[raster > max] <- max
      (raster - min)/(max-min) * 254
  }

    named.glcm <- function(tile.dir, tile.basename, band.appendage, window, statistics, shift, na_opt, na_val,...) {

        tile.path <- paste0(tile.dir, "/", tile.basename,band.appendage,".tif")
        x <- raster(tile.path)

        mnx <- NULL
        mxx <- NULL
        if(band.appendage == "_ratio.nir") {
            mnx <- 20
            mxx <- 115
        }

        if (band.appendage == "_ratio.red") {
            mnx <- 27
            mxx <-97
        }

  x[x > mxx] <- mxx
  x[x < mnx] <- mnx

        if (statistics == "correlation") {
            texture <- glcm(x, window = window, statistics = statistics, shift = shift, na_opt = na_opt, na_val = na_val, min_x =mnx, max_x = mxx)
            texture[texture < -1] <- -1
            texture[texture > 1] <- 1
            texture[is.na(texture)] <- 1
            texture <- rescale.0.254(texture, -1, 1)
        } else {
            texture <- glcm(x, window = window, statistics = statistics, shift = shift, na_opt = na_opt, na_val = na_val, min_x = mnx, max_x =mxx)
            if(statistics == "homogeneity") texture <- trunc.rescale.0.254(texture, 0, 1)
            if(statistics == "contrast")  texture <- trunc.rescale.0.254(texture, 0, 70)
            if(statistics == "entropy")  texture <- trunc.rescale.0.254(texture, 0, 4)

        }
        win.size <- paste0("window.",window[1])
        shift.dir <- paste0("angle.",atan(shift[1]/shift[2])*180/pi) # calc shift angle
        shift.dir <- str_replace(shift.dir, "-","neg")

        tile.dir <- dirname(tile.path)
        tile.name <- str_sub(basename(tile.path),1,-5)
        fn = paste0(tile.dir,"/", tile.basename,band.appendage, "_stat.", statistics, "_", win.size,"_",shift.dir,".tif")
        writeRaster(texture, fn, overwrite = T, datatype = 'INT1U')
        }

            calc.texture <- function(texture.params.df,
                                     tile.dir,
                                     tile.basename) {

                texture <- mapply(named.glcm,
                                  tile.dir = tile.dir,
                                  tile.basename = tile.basename,
                                  band.appendage = texture.params.df$band.appendage,
                                  window = texture.params.df$window,
                                  statistics = texture.params.df$statistics,
                                  shift = texture.params.df$shift,
                                  na_opt = "center",
                                  na_val = NA)
            }

#+end_src

#+results:
*** Make new ratio bands from image
#+BEGIN_SRC R
  calc_ratios <- function(tile.path, band.names, ratio.bands, scale200 = T) {
      tile <- stack(tile.path)
      names(tile) <- band.names

      ratios <- tile[[ratio.bands,drop = F]] / sum(tile)

      if (scale200 == T) {
          ratios <- ratios * 200
      }

      tile.name <- str_sub(basename(tile.path),1,-5)
      names(ratios) <- paste0(tile.name,"_ratio.",ratio.bands)
      writeRaster(ratios, filename= paste0(dirname(tile.path),"/",names(ratios),".tif"),
                  bylayer = T, format= "GTiff", overwrite = T,
                  datatype = 'INT1U')
  }

  calc_ndvi <- function(tile.path, band.names, ndvi_appendage = "_ndvi", scale200 = T) {

      tile <- stack(tile.path)
      names(tile) <- band.names

      ndvi <- (tile[["nir"]] - tile[["red"]]) /  (tile[["nir"]] + tile[["red"]])

      ndvi [ndvi < 0] <- 0

      if (scale200 == T) {
          ndvi <- ndvi * 200
      }

      tile.dir <- dirname(tile.path)
      tile.name <- str_sub(basename(tile.path),1,-5)
      writeRaster(ndvi, filename=paste0(tile.dir,"/",tile.name,ndvi_appendage,".tif"), bylayer=TRUE,format="GTiff", overwrite = T,datatype = 'INT1U')
      return(ndvi)
  }
#+end_src

#+results:
*** Make Window/Focal Features
#+begin_src R

  ## raster.dir <- "../WholeState_DD/QualitativeAccuracy/NAIP"
  ## raster.name <- c("mad1_blue")
  ## fun <- c("mean")
  ## window.diameter <- c(1,2,4,8)
  ## feature.pattern = "_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi|ratio.nir_stat\\.\\w+_window\\.3_angle\\..?\\d+|ratio.red_stat\\.\\w+_window\\.3_angle\\..?\\d+|ratio.nir_stat\\.\\w+_window\\.5_angle\\..?\\d+).tif$"

  ## feature.pattern = "_(ndvi).tif$"


  ## raster.name <- remove.tif.ext(list.files(raster.dir, feature.pattern))

  ## focal.param.df <- expand.grid(raster.dir = raster.dir,
  ##                               raster.name = raster.name,
  ##                               fun = fun,
  ##                               window.diameter = window.diameter,
  ##                               stringsAsFactors = F)


  ## make.focal.features(focal.param.df)

  make.focal.features <- function(focal.param.df) {
      mapply(focal.name.and.writeRaster, focal.param.df$raster.dir, focal.param.df$raster.name, fun = focal.param.df$fun, window.diameter = focal.param.df$window.diameter)
  }


  circular.weight <- function(rs, d) {
          nx <- 1 + 2 * floor(d/rs[1])
          ny <- 1 + 2 * floor(d/rs[2])
          m <- matrix(ncol=nx, nrow=ny)
          m[ceiling(ny/2), ceiling(nx/2)] <- 1
          if (nx == 1 & ny == 1) {
                  return(m)
          } else {
                  x <- raster(m, xmn=0, xmx=nx*rs[1], ymn=0, ymx=ny*rs[2], crs="+proj=utm +zone=1 +datum=WGS84")
                  d <- as.matrix(distance(x)) <= d
                  d / sum(d)
          }
  }


  myfocalWeight <- function(x, d, type=c('circle', 'Gauss', 'rectangle')) {
          type <- match.arg(type)
          x <- res(x)
          x <- round(x)
          if (type == 'circle') {
                  circular.weight(x, d[1])
          } else if (type == 'Gauss') {
                  if (!length(d) %in% 1:2) {
                          stop("If type=Gauss, d should be a vector of length 1 or 2")
                  }
                  .Gauss.weight(x, d)
          } else {
                  .rectangle.weight(x, d)
          }
  }



  focal.name.and.writeRaster <- function(raster.dir,raster.name, fun, window.diameter, window.shape = "circle") {
      raster.path <- str_c(raster.dir,"/",raster.name,".tif")
      r <- raster(raster.path)
      extent(r) <- round(extent(r),digits = 5)
      rs <- round(res(r))
      res(r) <- rs
      fw <- myfocalWeight(r, window.diameter, type = window.shape)
      if(fun == "min")    fw[fw==0] <- NA  # if fun is min and fw has 0's in it, the raster becomes 0's
      out <- focal(r, match.fun(fun), w = fw, na.rm = T, pad = T) * sum(fw != 0, na.rm = T)
      names(out) <- paste0(names(r), "_window",window.shape,"-",window.diameter,"_fun-",fun)
      writeRaster(out, file = str_c(raster.dir,"/",names(out),".tif"), overwrite = T, datatype = 'INT1U')
      return(out)
  }

#+end_src

#+RESULTS:

*** Make Pixel feature df
Feature DF
#+begin_src R
  save.pixel.feature.df <- function(tile.dir,
                                    tile.name,
                                    feature.pattern,
                                    feature.df.append = feature.df.appendage ) {
      s <- stack(list.files(tile.dir, pattern = paste0(tile.name,feature.pattern), full.names = T))
      names(s) <- sub(x = names(s), pattern = paste0("(",tile.name,"_)"), replacement = "")
      s.df <- as.data.frame(s, xy = T)
      saveRDS(s.df, file = paste0(tile.dir, "/", tile.name, "_Pixel",feature.df.append, ".rds"))
  }


  ## this function replaced with make.focal.features and then save.pixel.feature.df
  ##   save.pixel.feature.wWindows.df <- function(tile.dir,
  ##                                     tile.name,
  ##                                     feature.pattern,
  ##                                     feature.df.append = feature.df.appendage,
  ##                                     window.sizes = c(3,5,9),
  ##                                     sample.size = "none") {

  ##       s <- stack(list.files(tile.dir, pattern = paste0(tile.name,feature.pattern), full.names = T))

  ##       names(s) <- sub(x = names(s), pattern = paste0("(",tile.name,"_)"), replacement = "")

  ##      out <- lapply(s@layers, function(ras) {
  ##         lapply(window.sizes, function(w.s) {
  ##           mean <- focal(ras, fun = mean, w = matrix(1, nrow = w.s, ncol = w.s), na.rm = T, pad = T)
  ##           names(mean) <- paste0(names(ras),"_windowSize-",w.s,"_fun-mean")

  ##           max <- focal(ras, fun = max, w = matrix(1, nrow = w.s, ncol = w.s), na.rm = T, pad = T)
  ##           names(max) <- paste0(names(ras),"_windowSize-",w.s,"_fun-max")

  ##           min <- focal(ras, fun = min, w = matrix(1, nrow = w.s, ncol = w.s), na.rm = T, pad = T)
  ##           names(min) <- paste0(names(ras),"_windowSize-",w.s,"_fun-min")

  ## #          sd <- focal(ras, fun = sd, w = matrix(1, nrow = w.s, ncol = w.s), na.rm = T, pad = T)
  ## #         names(sd) <- paste0(names(ras),"_windowSize-",w.s,"_fun-sd")

  ##           out <- stack(mean, max, min, sd)
  ##         })
  ##       })

  ##       s.focal <- do.call("stack",unlist(out))
  ##       s <- stack(s,s.focal)
  ##       s.df <- as.data.frame(s, xy = T)

  ## if (sample.size != "none"){
  ##       s.df <- s.df[sample(1:nrow(s.df), size = max(c(sample.size,nrow(s.df)))),]
  ## }
  ##       saveRDS(s.df, file = paste0(tile.dir, "/", tile.name, "_Pixel",feature.df.append, ".rds"))
  ##   }


#+end_src

#+results:
*** Image PCA

#+BEGIN_SRC R

  pca.transformation <- function(tile.dir,
                                 image.name,
                                 tile.name,
                                 loc,
                                 feature.pattern = "_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi).tif",
                                 pca.append = pca.appendage,
                                 out.image.appendage = pca.appendage,
                                 comps.to.use = c(1,2,3),
                                 pca.dir = dd.pca.dir) {

      s <- stack(list.files(tile.dir, pattern = paste0(tile.name,feature.pattern), full.names = T))
      names(s) <- sub(x = names(s), pattern = ".*_", replacement = "")

      pca.model <- readRDS(str_c(pca.dir,"/",loc,image.name,pca.append,".rds"))

      r <- predict(s, pca.model, index = comps.to.use)

      min.r <- getRasterMin(r)
      max.r <- getRasterMax(r)
      rescaled.r <- rescale.0.254(r, min.r, max.r)

      out.path <- str_c(tile.dir, "/", tile.name, out.image.appendage, ".tif")
      writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U', bylayer = F)
  }


  getRasterMin <- function(t) {
      return(min(cellStats(t, stat = "min")))
  }

  getRasterMax <- function(t) {
      return(max(cellStats(t, stat = "max")))
  }

  rescale.0.254 <- function(raster,
                            min,
                            max) {
                                (raster - min)/(max-min) * 254
  }

  rescale.0.b <- function(raster, b, each.band = T) {
      if (each.band == T) {
          min <- cellStats(raster, stat = "min")
          max <- cellStats(raster, stat = "max")
      } else {
          min <- getRasterMin(raster)
          max <- getRasterMax(raster)
      }
      (raster - min)/(max-min) * b
  }


  ## image.pca <- function(image.name,
  ##                       pca.model.name.append = pca.model.name.appendage,
  ##                       tile.dir,
  ##                       tile.name,
  ##                       in.image.appendage = ratio.tile.name.append,
  ##                       out.image.appendage = pca.tile.name.append,
  ##                       band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi"),
  ##                       comps.to.use = c(1,2,3),
  ##                       pca.dir = dd.pca.dir) {


  ##     out.path <- str_c(tile.dir, "/", tile.name, out.image.appendage, ".tif")

  ##     s <- stack(str_c(tile.dir, "/", tile.name, in.image.appendage,".tif"))
  ##     names(s) <- band.names

  ##     pca.model <- readRDS(str_c(pca.dir,"/",image.name,pca.model.name.append))

  ##     r <- predict(s, pca.model, index = comps.to.use)

  ##     min.r <- getRasterMin(r)
  ##     max.r <- getRasterMax(r)
  ##     rescaled.r <- rescale.0.255(r, min.r, max.r)
  ##     writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U')
  ## }


  make.and.save.pca.transformation <- function(image.dir,
                                               image.name,
                                               location,
                                               pca.append = pca.appendage,
                                               max.sample.size = 10000,
                                               core.num = cores,
                                               feature.pattern = ".*_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi).tif",
                                               ratio.appendage = ratio.tile.name.append) {

      tile.paths <- list.files(image.dir, pattern = paste0(feature.pattern), full.names = T)

      tile.names <- str_match(tile.paths,"(.*\\.[0-9]+)_.*")[,2] %>%  unique() # get the image names of pca regions

      cl <- makeCluster(cores)
      registerDoParallel(cl)

      sr <- foreach (tile.name = tile.names, .packages = c("stringr","raster"), .combine ="rbind") %dopar% {
          t.names <- str_extract(tile.paths, paste0(".*",tile.name,".*")) %>% na.omit()
          tile <- stack(t.names)
          names(tile) <- sub(x = names(tile), pattern = ".*_", replacement = "")
          samp <- sampleRandom(tile, ifelse(ncell(tile) > max.sample.size ,max.sample.size, ncell(tile)))
          colnames(samp) <- names(tile)
          samp
      }
      closeAllConnections()

                                          # Perform PCA on sample
      pca <- prcomp(sr, scale = T)
      saveRDS(pca,paste0(image.dir,"/",location,image.name,pca.append,".rds"))
      return(pca)
  }



  make.and.save.pca.transformation.wholestate <- function(image.dir,
                                                          image.name,
                                                          location,
                                                          pca.append = pca.appendage,
                                                          max.sample.size = 10000,
                                                          core.num = cores,
                                                          feature.pattern = ".*_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi).tif",
                                                          Recurs = F) {
                                          #                                               ratio.append = ratio.appendage) {

      tile.paths <- list.files(image.dir, pattern = feature.pattern, full.names = T, recursive = Recurs)

      tile.names <- str_match(tile.paths,"(.*)_.*")[,2] %>%  unique() # get the image names of pca regions

      cl <- makeCluster(cores)
      registerDoParallel(cl)

      sr <- foreach (tile.name = tile.names, .packages = c("stringr","raster"), .combine ="rbind") %dopar% {
          t.names <- str_extract(tile.paths, paste0(".*",tile.name,"_.*")) %>% na.omit()
          tile <- stack(t.names)
          names(tile) <- sub(x = names(tile), pattern = ".*_", replacement = "")
          samp <- sampleRandom(tile, ifelse(ncell(tile) > max.sample.size ,max.sample.size, ncell(tile)))
          colnames(samp) <- names(tile)
          samp
      }
      closeAllConnections()

                                          # Perform PCA on sample
      pca <- prcomp(sr, scale = T)
      saveRDS(pca,paste0(image.dir,"/",location,image.name,pca.append,".rds"))
      return(pca)
  }


  ## make.and.save.pca.transformation <- function(image.dir,
  ##                                              image.name,
  ##                                              pca.model.name.append = "_pca.rds",
  ##                                              max.sample.size = 10000,
  ##                                              core.num = cores,
  ##                                              band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi"),
  ##                                              ratio.appendage = ratio.tile.name.append) {
  ##     tile.paths <- list.files(str_c(image.dir), pattern = paste0("*",ratio.appendage), full.names = T)

  ##     tile.names <- basename(tile.paths)

  ##     cl <- makeCluster(core.num)
  ##     registerDoParallel(cl)

  ##     sr <- foreach (i = seq_along(tile.names), .packages = c("raster"), .combine ="rbind") %dopar% {
  ##         tile <- stack(tile.paths[i])
  ##         s <- sampleRandom(tile, ifelse(ncell(tile) > max.sample.size ,max.sample.size, ncell(tile)))
  ##     }

  ##     colnames(sr) <- band.names

  ##                                         # Perform PCA on sample
  ##     pca <- prcomp(sr, scale = T)
  ##     saveRDS(pca,paste0(image.dir,"/",image.name,pca.model.name.append))

  ##     return(pca)
  ## }


  image.pca.forWholeState <- function(pca.model.name.append = pca.model.name.appendage,
                                      tile.dir,
                                      tile.name,
                                      in.image.appendage = ratio.tile.name.append,
                                      out.image.appendage = pca.tile.name.append,
                                      band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi"),
                                      comps.to.use = c(1,2,3),
                                      pca.transform) {


      out.path <- str_c(tile.dir, "/", tile.name, out.image.appendage, ".tif")

      s <- stack(str_c(tile.dir, "/", tile.name, in.image.appendage,".tif"))
      names(s) <- band.names

      r <- predict(s, pca.transform, index = comps.to.use)

      min.r <- getRasterMin(r)
      max.r <- getRasterMax(r)
      rescaled.r <- rescale.0.254(r, min.r, max.r)
      writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U')
  }



  ## image.dir <- image.cropped.to.training.dir
  ## image.name <- 9
  ##                         in.image.appendage = ratio.tile.name.append
  ##                         out.image.appendage = pca.tile.name.append
  ##                         band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi")
  ##                         max.sample.size = 10000
  ##                         comps.to.use = c(1,2,3)

  ##       out.path <- str_c(image.dir, "/", image.name, out.image.appendage, ".tif")

  ##       s <- stack(str_c(image.dir, "/", image.name, in.image.appendage,".tif"))
  ##       names(s) <- band.names

  ##       sr <- sampleRandom(s, ifelse(ncell(s) > max.sample.size, max.sample.size, ncell(s)))
  ##       pca <- prcomp(sr, scale = T)

  ##       r <- predict(s, pca, index = comps.to.use)

  ##       min.r <- getRasterMin(r)
  ##       max.r <- getRasterMax(r)
  ##       rescaled.r <- rescale.0.255(r, min.r, max.r)
  ##       writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U')









                                          # Function takes raster stack, samples data, performs pca and returns stack of first n_pcomp bands
  ## predict_pca_wSampling_parallel <- function(stack, sampleNumber, n_pcomp, nCores = detectCores()-1) {
  ##     sr <- sampleRandom(stack,sampleNumber)
  ##     pca <- prcomp(sr, scale=T)
  ##     beginCluster()
  ##     r <- clusterR(stack, predict, args = list(pca, index = 1:n_pcomp))
  ##     endCluster()
  ##     return(r)
  ## }
#+END_SRC

#+RESULTS:
*** Segment image
This simply is a wrapper for the python script which is basically a
wrapper for slic.

#+begin_src R
  segment.multiple <- function(tile.dir,
                               tile.name,
                               image.name,
                               segment.params.df,
                               krusty  = T) {
      segments <- mapply(segment,
                         tile.dir = tile.dir,
                         image.name = image.name,
                         tile.name = tile.name,
                         compactness = segment.params.df$compactness,
                         segment.size = segment.params.df$segment.size,
                         krusty = krusty)
  }

  segment  <- function(tile.dir,
                       image.name,
                       tile.name,
                       compactness,
                       segment.size,
                       krusty = T) {
      pixel_size <- ifelse(image.name == "NAIP", 1, 1.5)
      compactness <- if(image.name == "NAIP") compactness else round(2/3*compactness)
      if (krusty == T) {
          system(paste("/home/erker/.conda/envs/utc/bin/python","fia_segment_cmdArgs.py",pixel_size,segment.size,compactness,tile.name,tile.dir))
      } else {
          system(paste("python","fia_segment_cmdArgs.py",pixel_size,segment.size,compactness,tile.name,tile.dir))
      }
  }
#+end_src

#+results:
*** add.features

#+begin_src R
  add.features <- function(tile.dir,
                           tile.name,
                           band.names,
                           ndvi = T,
                           ratio.bands,
                           texture = T,
                           texture.params.df) {

      til.path <- paste0(tile.dir,"/",tile.name,".tif")
      til <- stack(til.path)
      names(til) <- band.names

      save_each_band(tile.path = til.path,
                     band.names = band.names)

      if (ndvi == T) {
          calc_ndvi(tile.path = til.path,
                    band.names = band.names)
      }

      if (length(ratio.bands > 0)) {
          calc_ratios(tile.path = til.path,
                      band.names = band.names,
                      ratio.bands = ratio.bands)
      }

      if (texture == T) {
          calc.texture(texture.params.df = texture.params.df,
                       tile.dir = tile.dir,
                       tile.basename = tile.name)
      }
  }

#+end_src

#+results:
*** segment Feature DF
#+begin_src R
  make.segment.feature.df.foreach.segmentation <- function(tile.dir,
                                                           tile.name,
                                                           feature.pattern,
                                                           segmentation.pattern = "_N-[0-9]+_C-[0-9]+.*") {

      segmentation.files <-  list.files(tile.dir, pattern = paste0(tile.name,segmentation.pattern))
      segmentation.param.appendages <- str_match(segmentation.files,paste0(tile.name,"(_.*).tif"))[,2] %>% na.omit()


      out <- lapply(X = segmentation.param.appendages, FUN = function(segmentation.param.appendage) {
          make.segment.feature.df(tile.dir = tile.dir,
                                  tile.name = tile.name,
                                  segmentation.param.appendage = segmentation.param.appendage,
                                  fea.pattern = feature.pattern)
      })

  }


  make.segment.feature.df <- function(tile.dir,
                                      tile.name,
                                      segmentation.param.appendage,
                                      fea.pattern,
                                      feature.df.append = feature.df.appendage) {

      fea <- stack(list.files(tile.dir, pattern = paste0(tile.name,fea.pattern), full.names = T))
                                          #      names(fea) <- sub(x = names(fea), pattern = "(madisonNAIP|madisonPanshpSPOT|urbanExtent|wausauNAIP).*?_", replacement = "")
      names(fea) <- sub(x = names(fea), pattern = "(.*?)_", replacement = "")
      seg.path <- paste0(tile.dir,"/",tile.name,segmentation.param.appendage, ".tif")
      seg <- raster(seg.path)

                                          # Create a data_frame where mean and variances are calculated by zone
      x <- as.data.frame(fea, xy = T)
      s <- as.data.frame(seg)
      colnames(s) <- "segment"
      r <- bind_cols(x,s)
      r2 <- r %>%
          group_by(segment)

      mean.max.min.and.sd <- r2 %>%
          summarize_each(funs(mean(.,na.rm = T), sd(., na.rm = T), max(., na.rm = T), min(., na.rm = T))) %>%
          select(-x_mean, -x_sd, -y_mean, -y_sd, -x_max, -x_min, -y_max, -y_min)

      tile.name.df = data.frame(tile.name = rep(tile.name, nrow(mean.max.min.and.sd)))

      out <- bind_cols(mean.max.min.and.sd, tile.name.df)


      names <- colnames(out)
      names <- str_replace(names, "\\(",".")
      names <- str_replace(names, "\\)",".")
      names <- str_replace(names, "\\:",".")
      colnames(out) <- names
      saveRDS(out, file = paste0(tile.dir,"/",tile.name,segmentation.param.appendage,feature.df.append,".rds"))
      out
  }



                                          #  make.segment.feature.df(dd.training.dir, "madisonNAIP.1", segmentation.param.appendage = "_N-100_C-10", feature.pattern = feature.pattern)

#+end_src

#+results:

*** make.feature.df
#+begin_src R

  make.feature.df <- function(tile.dir,
                              image.name,
                              tile.name,
                              band.names,
                              ndvi = T,
                              ratio.bands,
                              texture = T,
                              texture.params.df,
                              feature.pattern = "_(blue.*|green.*|red.*|nir.*|ratio.blue.*|ratio.green.*|ratio.red.*|ratio.nir.*|ndvi.*|ratio.red_stat\\.\\w+_window\\.\\d+_angle\\..?\\d+|ratio.nir_stat\\.\\w+_window\\.\\d+_angle\\..?\\d+).tif",
                              focal.features = T,
                              focal.params.df,
                              pixel.df,
                                          #                              pca.features = c("blue","green","red","nir","ndvi","ratio.blue","ratio.green","ratio.red","ratio.nir"),
                              pca.features = c("red","green","blue","nir"),
                              pca.location,
                              pca.directory = dd.pca.dir,
                              segmentation = T,
                              segment.params.df,
                              using.krusty = T) {

      add.features(tile.dir,
                   tile.name,
                   band.names,
                   ndvi = T,
                   ratio.bands,
                   texture = T,
                   texture.params.df)

      if (focal.features == T) {
          make.focal.features(focal.params.df)
      }


      message ( tile.name,"features added")

      if (pixel.df ==T) {

          save.pixel.feature.df(tile.dir = tile.dir,
                                tile.name = tile.name,
                                feature.pattern)}

      message("pixel feature df saved")

      if (segmentation == T) {

          pca.transformation(tile.dir = tile.dir,
                             tile.name = tile.name,
                             image.name = image.name,
                             loc = pca.location,
                             pca.dir = pca.directory)

          message("pca done")

          segment.multiple(tile.dir = tile.dir,
                           tile.name = tile.name,
                           image.name = image.name,
                           segment.params.df = segment.params.df,
                           krusty = using.krusty)

          message("segmentation done")

          make.segment.feature.df.foreach.segmentation(tile.dir = tile.dir,
                                                       tile.name = tile.name,
                                                       feature.pattern = feature.pattern)}



  }


#+end_src

#+results:

** remove tif ext
#+begin_src R
  remove.tif.ext <- function(x) {
      str_match(x, "(.*).tif")[,2]
  }

#+end_src

#+RESULTS:

* data
** image
#+begin_src R
r <- stack("data/image/m_4409047_ne_15_1_20130701.tif")
#+end_src

#+RESULTS:
* crop image to subset of training
#+begin_src R
rc <- crop(r, extent(s))
writeRaster(rc, "data/image/train/m_4409047_ne_15_1_20130701_train.tif", overwrite = T)
#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file figs/train.png
plotRGB(rc, 1,2,3)
plot(s, add = T)
#+end_src

#+RESULTS:
[[file:figs/train.png]]

* add some additional features/layers

#+begin_src R

    add.features(tile.dir = "data/image/train/",
                 tile.name = "m_4409047_ne_15_1_20130701_train",
                 band.names = c("red","green","blue","nir"),
                 ratio.bands = c("red","green","blue","nir"),
                 texture = T,
                 texture.params.df = texture.params)

#+end_src

#+RESULTS:


#+begin_src R
  library(parallel)
    library(doParallel)
  cores <- detectCores() - 1

    cl <- makeCluster(cores)
    registerDoParallel(cl)

    focal.feature.pattern = "_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi).tif$"
    focal.fun <- c("mean","max","min")
    focal.window.diameter <- c(2,4,8,11)

    tile.names <- remove.tif.ext(list.files("data/image/train", focal.feature.pattern))

    focal.param.df <- expand.grid(raster.dir = "data/image/train/",
                                  raster.name = tile.names,
                                  fun = focal.fun,
                                  window.diameter = focal.window.diameter,
                                  stringsAsFactors = F)

        features <- foreach (i = 1:nrow(focal.param.df),
                             .packages = c("raster","stringr")) %dopar% {
                                 make.focal.features(focal.param.df[i,])
                             }

#+end_src

#+RESULTS:

* stack training
#+begin_src R
  train.stack <- stack(list.files("data/image/train", full.names = T, pattern = ".*train_.*.tif$"))

  ## f <- list.files("data/image/train", full.names = T, pattern = ".*train_.*.tif$")

  ## conv <- str_extract(f, ".*windowcircle.(11|2|4|8).*") %>% na.omit()
  ## text <- str_extract(f, ".*stat.*window.(5|11).*") %>% na.omit()
  ## f <- c(conv, text)
  ## train.stack <- stack(f)

#+end_src

#+RESULTS:
* extract values at training areas
These pngs come from gimp.
#+begin_src R
snag <- raster("data/training/snags.png")
other <- raster("data/training/other.png")
livetree <- raster("data/training/livetree.png")
liveveg <- raster("data/training/liveveg.png")

#+end_src

#+RESULTS:

#+begin_src R
    snag.cells <- which(getValues(snag == 255))
    snag.df <- data.frame(cell = snag.cells, Class = "snag")

    liveveg.cells <- sample(which(getValues(liveveg == 255)),20000)
    liveveg.df <- data.frame(cell = liveveg.cells, Class = "liveveg")

    livetree.cells <- sample(which(getValues(livetree == 255)),20000)
    livetree.df <- data.frame(cell = livetree.cells, Class = "livetree")

    other.cells <- sample(which(getValues(other == 255)),17000)
    other.df <- data.frame(cell = other.cells, Class = "other")

  ext_ID <- do.call("bind", list(snag.df, liveveg.df, livetree.df, other.df))
#+end_src

#+RESULTS:

#+begin_src R :eval yes

  mat1 <- ff(vmode="integer",dim=c(ncell(train.stack),80),filename="data/image/train/trainstack1.ffdata")
  mat2 <- ff(vmode="integer",dim=c(ncell(train.stack),80),filename="data/image/train/trainstack2.ffdata")
  mat3 <- ff(vmode="integer",dim=c(ncell(train.stack),nlayers(train.stack)-160),filename="data/image/train/trainstack3.ffdata")

  for(i in 1:80){
      mat1[,i] <- train.stack[[i]][]
  }

  for(i in 1:80){
      mat2[,i] <- train.stack[[80+i]][]
  }

  for(i in 1:(nlayers(train.stack)-160)){
      mat3[,i] <- train.stack[[160+i]][]
  }


  save(mat1,file="data/image/train/train_stack_mat1.RData")
  save(mat2,file="data/image/train/train_stack_mat2.RData")
  save(mat3,file="data/image/train/train_stack_mat3.RData")

  extracted.values1 <- mat1[ext_ID$cell,]
  extracted.values2 <- mat2[ext_ID$cell,]
  extracted.values3 <- mat3[ext_ID$cell,]

  extracted.values <- cbind(extracted.values1, extracted.values2, extracted.values3)

  df <- data.frame(extracted.values)
  colnames(df) <- paste0("X",str_match(names(train.stack), "train(.*)")[,2])

  df$Class <- factor(ext_ID$Class)
#+end_src

#+RESULTS:

#+begin_src R
saveRDS(df, "data/training/model_building_df.rds")
#+end_src

#+RESULTS:

* build model
#+begin_src R

df <- readRDS("data/training/model_building_df.rds")

#+end_src

#+RESULTS:

#+begin_src R
#df <- df[,!grepl(".*stat.*",colnames(df))]
#+end_src

#+RESULTS:

#+begin_src R
df <- df %>% na.omit()
#+end_src

#+RESULTS:

#+begin_src R
mod_all <- randomForest(y = factor(df$Class), x= df[,1:(dim(df)[2]-1)])
#+end_src

#+RESULTS:

#+begin_src R :eval yes
top <- arrange(data.frame(importance(mod_all), name = row.names(importance(mod_all))), -MeanDecreaseGini) %>% head(100)
saveRDS(top, "data/training/top.rds")
top
#+end_src

#+RESULTS:
#+begin_example
 
   MeanDecreaseGini                                            name
1         1768.84944                                     X_ratio.nir
2         1333.06552             X_ratio.nir_windowcircle.4_fun.mean
3         1289.97356             X_ratio.nir_windowcircle.2_fun.mean
4         1174.63354             X_ratio.nir_windowcircle.8_fun.mean
5         1047.10641            X_ratio.blue_windowcircle.2_fun.mean
6         1009.00493            X_ratio.blue_windowcircle.4_fun.mean
7          992.66199              X_ratio.nir_windowcircle.2_fun.max
8          969.00457                  X_ndvi_windowcircle.2_fun.mean
9          959.62803                  X_ndvi_windowcircle.4_fun.mean
10         917.44394                                           X_nir
11         912.35043                                    X_ratio.blue
12         911.01801                                         X_green  
13         774.56996             X_ratio.blue_windowcircle.2_fun.max
14         755.73220            X_ratio.blue_windowcircle.8_fun.mean
15         737.34341                                          X_ndvi
16         736.72931              X_ratio.nir_windowcircle.2_fun.min
17         714.16654                 X_green_windowcircle.2_fun.mean
18         697.19038                   X_nir_windowcircle.2_fun.mean
19         663.84339                   X_nir_windowcircle.4_fun.mean
20         652.64024                  X_ndvi_windowcircle.8_fun.mean
21         581.64994                   X_ndvi_windowcircle.2_fun.max
22         577.18978                                   X_ratio.green
23         573.27182           X_ratio.blue_windowcircle.11_fun.mean
24         570.74299            X_ratio.nir_windowcircle.11_fun.mean
25         530.18416                    X_nir_windowcircle.2_fun.min
26         521.25479           X_ratio.green_windowcircle.8_fun.mean
27         481.65480                 X_green_windowcircle.4_fun.mean
28         440.89344                  X_green_windowcircle.2_fun.max
29         434.12899                   X_ndvi_windowcircle.2_fun.min
30         426.76268             X_ratio.blue_windowcircle.2_fun.min
31         402.61021          X_ratio.green_windowcircle.11_fun.mean
32         397.77869             X_ratio.red_windowcircle.4_fun.mean
33         387.35051              X_ratio.nir_windowcircle.4_fun.max
34         380.64760                                     X_ratio.red
35         363.88933                   X_nir_windowcircle.8_fun.mean
36         356.50107                  X_nir_windowcircle.11_fun.mean
37         335.27027                    X_nir_windowcircle.4_fun.min
38         330.28846           X_ratio.green_windowcircle.2_fun.mean
39         330.26788                    X_nir_windowcircle.2_fun.max
40         314.72791             X_ratio.red_windowcircle.2_fun.mean
41         305.83739                  X_red_windowcircle.11_fun.mean
42         301.83040             X_ratio.blue_windowcircle.4_fun.max
43         301.01883           X_ratio.green_windowcircle.4_fun.mean
44         291.88915             X_ratio.red_windowcircle.8_fun.mean
45         290.48709                X_green_windowcircle.11_fun.mean
46         285.77284                 X_green_windowcircle.8_fun.mean
47         265.53155            X_ratio.green_windowcircle.2_fun.max
48         257.28524                   X_red_windowcircle.2_fun.mean
49         248.26860              X_ratio.red_windowcircle.4_fun.min
50         236.14855                                           X_red
51         232.66594                  X_green_windowcircle.4_fun.max
52         230.03166                 X_ndvi_windowcircle.11_fun.mean
53         215.54380              X_ratio.red_windowcircle.2_fun.min
54         204.40266                    X_nir_windowcircle.8_fun.min
55         171.29279                   X_nir_windowcircle.11_fun.min
56         166.43519              X_ratio.nir_windowcircle.4_fun.min
57         163.16487              X_ratio.nir_windowcircle.8_fun.max
58         157.63675                                          X_blue
59         151.51567                    X_nir_windowcircle.4_fun.max
60         146.18572                   X_ndvi_windowcircle.4_fun.max
61         142.22258                   X_red_windowcircle.8_fun.mean
62         140.89418              X_ratio.red_windowcircle.2_fun.max
63         135.98580            X_ratio.red_windowcircle.11_fun.mean
64         135.44642                  X_ndvi_windowcircle.11_fun.max
65         133.32258             X_ratio.blue_windowcircle.4_fun.min
66         126.41983            X_ratio.green_windowcircle.4_fun.max
67         126.04495                   X_red_windowcircle.4_fun.mean
68         125.92349                  X_blue_windowcircle.2_fun.mean
69         108.54877             X_ratio.blue_windowcircle.8_fun.max
70         107.40232                    X_red_windowcircle.2_fun.max
71         105.19711           X_ratio.green_windowcircle.11_fun.min
72         104.46705             X_ratio.nir_windowcircle.11_fun.max
73         104.00360                  X_green_windowcircle.2_fun.min
74         100.93784                    X_red_windowcircle.4_fun.max
75         100.73962                   X_ndvi_windowcircle.8_fun.max
76          98.95299                  X_green_windowcircle.8_fun.min
77          98.04064            X_ratio.green_windowcircle.8_fun.min
78          94.07153                   X_ndvi_windowcircle.4_fun.min
79          93.65238                    X_red_windowcircle.8_fun.min
80          92.09329                 X_green_windowcircle.11_fun.min
81          87.23457            X_ratio.green_windowcircle.2_fun.min
82          85.47696            X_ratio.blue_windowcircle.11_fun.max
83          81.87583                  X_green_windowcircle.4_fun.min
84          78.18474           X_ratio.green_windowcircle.11_fun.max
85          78.01487                   X_blue_windowcircle.2_fun.max
86          77.26071                   X_nir_windowcircle.11_fun.max
87          76.50027                 X_green_windowcircle.11_fun.max
88          76.02308            X_ratio.green_windowcircle.8_fun.max
89          74.80251                   X_red_windowcircle.11_fun.min
90          67.45120                  X_ndvi_windowcircle.11_fun.min
91          66.82940 X_ratio.nir_stat.homogeneity_window.13_angle.90
92          63.48111                   X_ndvi_windowcircle.8_fun.min
93          61.86752                    X_red_windowcircle.8_fun.max
94          60.73315              X_ratio.nir_windowcircle.8_fun.min
95          60.55779             X_ratio.nir_windowcircle.11_fun.min
96          59.70714                  X_green_windowcircle.8_fun.max
97          56.25443                  X_blue_windowcircle.4_fun.mean
98          55.71303                   X_red_windowcircle.11_fun.max
99          55.20023            X_ratio.green_windowcircle.4_fun.min
100         51.96323             X_ratio.red_windowcircle.11_fun.max
#+end_example



build model with top variables
#+begin_src R
top <- readRDS("./data/training/top.rds")
mod <- randomForest(y = factor(df$Class), x= df[,c(as.character(top$name))]) 

saveRDS(mod, "data/training/training_mod100.rds")
#+end_src

#+begin_src R
  top <- readRDS("data/training/top.rds")
#+end_src

#+RESULTS:

* predict onto raster
#+begin_src R
names(train.stack.int) <- paste0("X",str_match(names(train.stack.int), "train(.*)")[,2])
pred.r <- raster::predict(train.stack.int, mod)
#+end_src

#+RESULTS:

#+begin_src R
writeRaster(pred.r, "data/image/prediction/prediction.tif",overwrite = T)
#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file figs/prediction_newer.png
plot(pred.r)
#+end_src

#+RESULTS:
[[file:figs/prediction_newer.png]]




[[file:figs/prediction.png]]

* test raster
** make test raster
#+begin_src R
  plot(s)
  e2 <- drawExtent()
#+end_src

#+begin_src R
dput(e2)
#+end_src

#+RESULTS:
: new("Extent"
:     , xmin = 728329.29711889
:     , xmax = 728630.128306831
:     , ymin = 4911115.04515934
:     , ymax = 4911376.10494422
: )

#+begin_src R
r.test <- crop(r, e2)

#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file figs/test.png
plotRGB(r.test,1,2,3)
#+end_src

#+RESULTS:
[[file:figs/test.png]]
#+begin_src R
writeRaster(r.test, "data/image/test/test.tif")
#+end_src

#+RESULTS:
** add some additional features/layers

#+begin_src R

  add.features(tile.dir = "data/image/test/",
               tile.name = "test",
               band.names = c("red","green","blue","nir"),
               ratio.bands = c("red","green","blue","nir"),
               texture = T,
               texture.params.df = texture.params)

#+end_src

#+RESULTS:


#+begin_src R

  cores <- detectCores() - 1

    cl <- makeCluster(cores)
    registerDoParallel(cl)

    focal.feature.pattern = "_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi).tif$"
    focal.fun <- c("mean","max","min")
    focal.window.diameter <- c(1,2,4,8,11)

    tile.names <- remove.tif.ext(list.files("data/image/test", focal.feature.pattern))

    focal.param.df <- expand.grid(raster.dir = "data/image/test/",
                                  raster.name = tile.names,
                                  fun = focal.fun,
                                  window.diameter = focal.window.diameter,
                                  stringsAsFactors = F)

        features <- foreach (i = 1:nrow(focal.param.df),
                             .packages = c("raster","stringr")) %dopar% {
                                 make.focal.features(focal.param.df[i,])
                             }

#+end_src

** convert to integer
*** stretch
#+begin_src R
test.stack <- stack(list.files("data/image/test", full.names = T, pattern = "test_.*.tif$"))
names(test.stack) <- str_match(names(test.stack), "test(.*)")[,2]
#+end_src

#+RESULTS:

#+begin_src R
      dir.create("data/image/test/int/")
      stretch.vals <- read.csv("data/training/stretchvals.csv")

        test.stack.int <- lapply(1:nlayers(test.stack), function(i) {
            nm <- names(test.stack[[i]])
            j <- which(stretch.vals[,"nms"] == nm)
            mn <- stretch.vals[j,1]
            mx <- stretch.vals[j,2]
            if (cellStats(test.stack[[i]], "min") < mn) {
                test.stack[[i]][test.stack[[i]] < mn] <- mn
            }
            if (cellStats(test.stack[[i]], "max") > mx) {
                test.stack[[i]][test.stack[[i]] > mx] <- mx
            }


            calc(test.stack[[i]], fun=function(x){((x - mn) * 254)/(mx- mn) + 0},
                 filename = paste0("data/image/test/int/",names(test.stack[[i]]),".tif"), datatype='INT1U', overwrite = T)
        })

#+end_src

#+RESULTS:
: Warning message:
: In dir.create("data/image/test/int/") :
:   'data/image/test/int' already exists

#+begin_src R
test.stack.int <- stack(list.files("data/image/test/int", full.names = T, pattern = ".*.tif$"))
#+end_src

#+RESULTS:

** predict on test raster

#+RESULTS:

#+begin_src R
pred.test <- predict(test.stack.int, mod)
#+end_src

#+RESULTS:

#+begin_src R :exports results :results graphics :file figs/pred_test.png
plot(pred.test)
#+end_src

#+RESULTS:
[[file:figs/pred_test.png]]

#+begin_src R
writeRaster(pred.test, "data/image/test/prediction.tif", overwrite = T, dataType = "INT1U")
#+end_src

#+RESULTS:
* Apply Model to NAIP images Cropped to 2km within MYSE captures
** read points

#+begin_src R
          library(readxl)
          library(sp)
          library(rgeos)
          library(maptools)
          library(dplyr)
          library(raster)
      library(stringr)
          d <- read_excel("data/NAIPImages/MYSE_captures_2014.xlsx")
          coordinates(d) <- ~long + lat
          proj4string(d) <- CRS("+init=epsg:4326")

          utms <- c("15","16")
          bufs <- lapply(utms, function(utm) {
              p <- spTransform(d, CRS(paste0("+init=epsg:269",utm)))
              buf <- gBuffer(p, width = 2000, byid = T)
              buf <- gUnion(buf, buf)
              buf <- disaggregate(buf)
              buf
      })


      names(bufs) <- c("utm15","utm16")
      shapefile(bufs$utm15, "data/NAIPImages/MYSE_captures_2014_utm15.shp", overwrite = T)
      shapefile(bufs$utm16, "data/NAIPImages/MYSE_captures_2014_utm16.shp", overwrite = T)


  p <- spTransform(d, CRS("+proj=tmerc +lat_0=0 +lon_0=-90 +k=0.9996 +x_0=520000 +y_0=-4480000 +ellps=GRS80 +units=m +no_defs"))
              buf <- gBuffer(p, width = 2000, byid = T)
              buf <- gUnion(buf, buf)
    bufs$wtm <- disaggregate(buf)

                  shapefile(bufs$wtm, "data/NAIPImages/MYSE_captures_2014_wtm.shp", overwrite = T)
#+end_src

#+RESULTS:
: Warning messages:
: 1: Setting row names on a tibble is deprecated. 
: 2: Setting row names on a tibble is deprecated.
** read images and crop to 2km
#+begin_src R

  image.files <- list.files("data/NAIPImages", recursive = T, full.names = T, pattern = ".*[0-9]{8}[_w]*.tif$")

  images <- lapply(image.files, function(image.file) stack(image.file))

  outdirs <- tools::file_path_sans_ext(image.files)

  sapply(outdirs, dir.create)

  extents <- lapply(images, function(i) extent(i))
  poly.extents <- lapply(extents, function(extent) as(extent, "SpatialPolygons"))
  poly.extents.merged <- do.call("bind", poly.extents)
  shapefile(poly.extents.merged, "data/NAIPImages/extents.shp", overwrite = T)
  projs <- sapply(images, function(i) proj4string(i))

  #cropped.images <- lapply(1:length(projs), function(i) {

  cropped.images <- lapply(19, function(i) {

      if(grepl(".*zone=15.*", projs[i])) {
          ci <- lapply(1:length(bufs$utm15), function(j) {
              #c.out.path <- paste0(tools::file_path_sans_ext(image.files[i]),"_cropped_",j,".tif")
              m.out.path <- paste0(tools::file_path_sans_ext(image.files[i]),"/masked_",j,".tif")

              if(gIntersects(poly.extents.merged[i,], bufs$utm15[j,])) {
                  c1 <- crop(images[[i]], bufs$utm15[j,])   #, filename = c.out.path, overwrite = T)
                  m1 <- mask(c1, bufs$utm15[j,]) #, filename = m.out.path, overwrite = T)
                  t1 <- trim(m1) #, filename = m.out.path, overwrite = T)
                  writeRaster(t1, filename = m.out.path, overwrite = T, options = c("PHOTOMETRIC=RGB", "ALPHA=YES"), datatype = "INT1U")
              }
          })
      }
    
  #utm16
      if(grepl(".*zone=16.*", projs[i])) {
          ci <- lapply(1:length(bufs$utm16), function(j) {
              #c.out.path <- paste0(tools::file_path_sans_ext(image.files[i]),"_cropped_",j,".tif")
              m.out.path <- paste0(tools::file_path_sans_ext(image.files[i]),"/masked_",j,".tif")
              if(gIntersects(poly.extents.merged[i,], bufs$utm16[j,])) {
                  c1 <- crop(images[[i]], bufs$utm16[j,])   #, filename = c.out.path, overwrite = T)
                  m1 <- mask(c1, bufs$utm16[j,]) #, filename = m.out.path, overwrite = T)
                  t1 <- trim(m1) #, filename = m.out.path, overwrite = T)
                  writeRaster(t1, filename = m.out.path, overwrite = T, options = c("PHOTOMETRIC=RGB", "ALPHA=YES"), datatype = "INT1U")
              }
          })
      }
    
  #wtm

      if(grepl(".*x_0=520000.*y_0=-4480000.*ellps=GRS80.*", projs[i])) {
          ci <- lapply(1:length(bufs$wtm), function(j) {
              #c.out.path <- paste0(tools::file_path_sans_ext(image.files[i]),"_cropped_",j,".tif")
              m.out.path <- paste0(tools::file_path_sans_ext(image.files[i]),"/masked_",j,".tif")
              if(gIntersects(poly.extents.merged[i,], bufs$wtm[j,])) {
                  c1 <- crop(images[[i]], bufs$wtm[j,])   #, filename = c.out.path, overwrite = T)
                  m1 <- mask(c1, bufs$wtm[j,]) #, filename = m.out.path, overwrite = T)
                  t1 <- trim(m1) #, filename = m.out.path, overwrite = T)
                  writeRaster(t1, filename = m.out.path, overwrite = T, options = c("PHOTOMETRIC=RGB", "ALPHA=YES"), datatype = "INT1U")
              }
          })
      }

  })
#+end_src
** add some additional features/layers

#+begin_src R

  tile.dirs <- list.dirs("data/NAIPImages/")
  tile.dirs <- tile.dirs[grepl(".*[0-9]{8}[_w]*", tile.dirs)]

    lapply(tile.dirs, function(tile.dir) {
        tile.names <- tools::file_path_sans_ext(list.files(tile.dir, pattern = ".*masked_[0-9]+.tif$"))
      lapply(tile.names, function(tile.name) {

          add.features(tile.dir = tile.dir,
                       tile.name = tile.name,
                       band.names = c("red","green","blue","nir"),
                       ratio.bands = c("red","green","blue","nir"),
                       texture = F,
                       texture.params.df = texture.params)
  })
  })
#+end_src


#+begin_src R
library(tidyr)

  cores <- 40

  tile.dirs <- list.dirs("data/NAIPImages/")
  tile.dirs <- tile.dirs[grepl(".*[0-9]{8}[_w]*", tile.dirs)]

  tile.dirs <- tile.dirs[2:length(tile.dirs)]

    lapply(tile.dirs, function(tile.dir) {
        tile.names <- tools::file_path_sans_ext(list.files(tile.dir, pattern = ".*masked_[0-9]+.tif$"))

        lapply(tile.names, function(tile.name) {
            cl <- makeCluster(cores)
            registerDoParallel(cl)


            focal.feature.pattern = "_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi).tif$"
            focal.fun <- c("mean","max","min")
            focal.window.diameter <- c(1,2,4,8,11)
            names <- remove.tif.ext(list.files(tile.dir, paste0(tile.name,focal.feature.pattern)))
            focal.param.df <- expand.grid(raster.dir = tile.dir,
                                          raster.name = names,
                                          fun = focal.fun,
                                          window.diameter = focal.window.diameter,
                                          stringsAsFactors = F)

                                            # only generating the top additional features

            funs <- str_match(as.character(top$name), "fun.([a-z]+)")[,2] %>% na.omit()
            windows <-str_match(as.character(top$name), "windowcircle.([0-9]+)")[,2] %>% as.numeric() %>% na.omit()
            names <- str_match(as.character(top$name), "X(_[a-z]+.[a-z]+)_window")[,2] %>% na.omit()
            names <- paste0(tile.name, names)

            top.focal.param.df <- data.frame(raster.dir = tile.dir,
                                         raster.name = names,
                                         fun = funs,
                                         window.diameter = windows,
                                         stringsAsFactors = F)

            fpdf <- focal.param.df %>% unite(com, raster.name, fun, window.diameter)
            tfpdf <- top.focal.param.df %>% unite(com, raster.name, fun, window.diameter)

            focal.param.df <- focal.param.df[!fpdf$com %in% tfpdf$com,]

            features <- foreach (i = 1:nrow(focal.param.df),
                                 .packages = c("raster","stringr"),
                                 .export = c('make.focal.features','focal.name.and.writeRaster','myfocalWeight','circular.weight')) %dopar% {

                                     make.focal.features(focal.param.df[i,])
                                 }

            closeAllConnections()
        })
    })
#+end_src

** Black River training data, Build model, and predict onto cropped images

#+begin_src R
    dates <- c("20130705","20130813")
  #  dates <- c("20130813")

                                            # for date in dates for which we have training data....
    lapply(dates, function(date) {
        tile.dirs <- list.dirs("data/NAIPImages/")

        tile.dirs <- tile.dirs[grepl(paste0(".*",date), tile.dirs)]

        lapply(tile.dirs, function(tile.dir) {

            train.date.imgs <- paste0(tile.dir, "_",c("liveveg","livetrees","other","snag"),"_masked.tif")
            if(file.exists(train.date.imgs[1])) {
                train.date.imgs <- lapply(train.date.imgs, raster)

                train.date.imgs <- lapply(train.date.imgs, function(r) {
                    cover <- str_extract(names(r), "(livetrees|liveveg|other|snag)")
                    cells <- which(getValues(r > 0))
                    df <- data.frame(cell = cells, Class = cover, stringsAsFactors = F)
                })

                ext_ID <- do.call("bind", train.date.imgs)

                f <- list.files(tile.dir, full.names = T, pattern = "masked_[0-9]+_.*.tif$")

                train.stack <- stack(f)

                fn <- paste0(tile.dir, ".ffdata")

                mat <- ff(vmode="integer",dim=c(ncell(train.stack),nlayers(train.stack)),filename=fn)
                                          #
                                          #
                                          #
                                          #
  ### We have a PROBLEM.  DATA is too big for FF OBJECTS!
# need fewer layers or smaller training images!!! argggggg!!!
                ####
                #mat <- ff(vmode="integer",dim=c(6002410, 140), filename=fn)

                for(i in 1:nlayers(train.stack)){
                    mat[,i] <- train.stack[[i]][]
                }

                save(mat,file=paste0(tile.dir, "_train.RData"))

                extracted.values <- mat[ext_ID$cell,]

                df <- data.frame(extracted.values)
                colnames(df) <- names(train.stack)

                df$Class <- factor(ext_ID$Class)

                saveRDS(df, paste0(tile.dir, "_model_building_df.rds"))
            }
        })

        dfs <- list.files("data/NAIPImages", pattern = paste0(".*",date,"_model_building_df.rds"), full.names = T, recursive = T)

        dfs <- lapply(dfs, readRDS)

        df <- do.call("rbind", dfs)

        df <- df %>% na.omit()
        mod <- randomForest(y = factor(df$Class), x= df[,1:(dim(df)[2]-1)])


        cores <- length(tile.dirs)

        cl <- makeCluster(cores)
        registerDoParallel(cl)

        features <- foreach (tile.dir = tile.dirs,
                             .packages = c("raster","stringr","randomForest")) %dopar% {

                                 st <- stack(list.files(tile.dir, full.names = T, pattern = ".*_[0-9]+_.*.tif$"))

                                 to_replace <- str_extract(names(mod$forest$ncat)[1], "masked_[0-9]_")
                                 names(st) <- str_replace(names(st), "masked_[0-9]+_", to_replace)

                                 pred.r <- raster::predict(st, mod, filename = paste0(tile.dir, "_predicted.tif"), overwrite = T, datatype = "INT1U")

                             }

    })

#+end_src

#+RESULTS:
: Error in ff(vmode = "integer", dim = c(ncell(train.stack), nlayers(train.stack)),  : 
:   length exceeds file length

** FlambeauRiver
The dates are so close together and the time of day is only different
by an hour, so I'm going to just build one model for flambeau
#+begin_src R
  f.dir <- "data/NAIPImages/FlambeauRiverSF2014/"

  imgs.wTraining <- list.files(f.dir, "m_[0-9]{7}_.*_masked.*.tif$") %>% na.omit()

  imgs <- str_extract(imgs.wTraining, "m_[0-9]{7}_.*_[0-9]{8}") %>% na.omit() %>% unique()

  lapply(imgs, function(img) {

      train.imgs <- list.files(f.dir, paste0(img, "_masked.*.tif$"), full.names = T)

      train.imgs <- lapply(train.imgs, raster)

      train.imgs <- lapply(train.imgs, function(r) {
          cover <- str_extract(names(r), "(livetrees|liveveg|other|snag)")
          cells <- which(getValues(r > 0))
          df <- data.frame(cell = cells, Class = cover, stringsAsFactors = F)
      })

      ext_ID <- do.call("bind", train.imgs)

      f <- list.files(paste0(f.dir, img), full.names = T, pattern = "masked_[0-9]+_.*.tif$")

      train.stack <- stack(f)

      fn <- paste0(f.dir,img, ".ffdata")

      mat <- ff(vmode="integer",dim=c(ncell(train.stack),nlayers(train.stack)),filename=fn)
                                          #
                                          #
                                          #
                                          #
  ### if data is too big for ff, need fewer layers or smaller training images!!! argggggg!!!

      for(i in 1:nlayers(train.stack)){
          mat[,i] <- train.stack[[i]][]
      }

      save(mat,file=paste0(f.dir,img, "_train.RData"))

      extracted.values <- mat[ext_ID$cell,]

      df <- data.frame(extracted.values)
      colnames(df) <- names(train.stack)

      df$Class <- factor(ext_ID$Class)

      saveRDS(df, paste0(f.dir,img, "_model_building_df.rds"))
  })


  dfs <- list.files(f.dir, pattern = paste0(".*","_model_building_df.rds"), full.names = T, recursive = T)

  dfs <- lapply(dfs, readRDS)

  for(i in 1:length(dfs)) {
      colnames(dfs[[i]])[1:(length(colnames(dfs[[i]]))-1)] <- str_match(colnames(dfs[[i]]), "^(masked_[0-9]+_)(.*)")[,3][1:(length(colnames(dfs[[i]]))-1)]
  }

  df <- do.call("rbind", dfs)

  df <- df %>% na.omit()

  df.s <- filter(df, Class == "snag")
  df.allelse <- filter(df, Class != "snag")
  df.sub <- sample_n(df.allelse, 350000)
  df.sub <- rbind(df.s, df.sub)

  mod <- randomForest(y = factor(df.sub$Class), x= df.sub[,1:(dim(df.sub)[2]-1)])


  saveRDS(mod, paste0(f.dir, "mod.rds"))


  imgs <- list.files(f.dir, pattern = "masked_[0-9]+.tif$", full.names = T, recursive = T)
  imgs <- str_extract(imgs, "m_[0-9]{7}.*/masked_[0-9]+")

  cores <- length(imgs)

  cl <- makeCluster(cores)
  registerDoParallel(cl)

  features <- foreach (img = imgs,
                       .packages = c("raster","stringr","randomForest")) %dopar% {

                           img.features <- list.files(f.dir, full.names = T, recursive = T)
                           img.features <- str_extract(img.features, paste0(".*",img,"_.*")) %>% na.omit

                           img.dir <- str_replace(paste0(f.dir,img), "masked_[0-9]+","")
                           st <- stack(list.files(img.dir, full.names = T, pattern = ".*_[0-9]+_.*.tif$"))

                                          #                         to_replace <- str_extract(names(mod$forest$ncat)[1], "masked_[0-9]_")

                           names(st) <- str_replace(names(st), "masked_[0-9]+_", "")

                           pred.r <- raster::predict(st, mod, filename = paste0(f.dir,img, "_predicted.tif"), overwrite = T, datatype = "INT1U")

                       }
#+end_src

** NHAL
NHAL is all in the same flightline.
#+begin_src R
  f.dir <- "data/NAIPImages/NHAL2013/"

  imgs.wTraining <- list.files(f.dir, "m_[0-9]{7}_.*_masked.*.tif$") %>% na.omit()

  imgs <- str_extract(imgs.wTraining, "m_[0-9]{7}_.*_[0-9]{8}") %>% na.omit() %>% unique()

  lapply(imgs, function(img) {

      train.imgs <- list.files(f.dir, paste0(img, "_masked.*.tif$"), full.names = T)

      train.imgs <- lapply(train.imgs, raster)

      train.imgs <- lapply(train.imgs, function(r) {
          cover <- str_extract(names(r), "(livetrees|liveveg|other|snag)")
          cells <- which(getValues(r > 0))
          df <- data.frame(cell = cells, Class = cover, stringsAsFactors = F)
      })

      ext_ID <- do.call("bind", train.imgs)

      f <- list.files(paste0(f.dir, img), full.names = T, pattern = "masked_12_.*.tif$")  #I changed it number to be "12", because the sw tile has both "11" and "12"

      train.stack <- stack(f)

      fn <- paste0(f.dir,img, ".ffdata")

      mat <- ff(vmode="integer",dim=c(ncell(train.stack),nlayers(train.stack)),filename=fn)
                                          #
                                          #
                                          #
                                          #
  ### if data is too big for ff, need fewer layers or smaller training images!!! argggggg!!!

      for(i in 1:nlayers(train.stack)){
          mat[,i] <- train.stack[[i]][]
      }

      save(mat,file=paste0(f.dir,img, "_train.RData"))

      extracted.values <- mat[ext_ID$cell,]

      df <- data.frame(extracted.values)
      colnames(df) <- names(train.stack)

      df$Class <- factor(ext_ID$Class)

      saveRDS(df, paste0(f.dir,img, "_model_building_df.rds"))
  })


  dfs <- list.files(f.dir, pattern = paste0(".*","_model_building_df.rds"), full.names = T, recursive = T)

  dfs <- lapply(dfs, readRDS)

  for(i in 1:length(dfs)) {
      colnames(dfs[[i]])[1:(length(colnames(dfs[[i]]))-1)] <- str_match(colnames(dfs[[i]]), "^(masked_[0-9]+_)(.*)")[,3][1:(length(colnames(dfs[[i]]))-1)]
  }

  df <- do.call("rbind", dfs)

  df <- df %>% na.omit()
  mod <- randomForest(y = factor(df$Class), x= df[,1:(dim(df)[2]-1)])

  saveRDS(mod, paste0(f.dir, "mod.rds"))

#+end_src

** Sandhill
All of these are also in thee same flightline
#+begin_src R
  f.dir <- "data/NAIPImages/Sandhill2013/"

  imgs.wTraining <- list.files(f.dir, "m_[0-9]{7}_.*_masked.*.tif$") %>% na.omit()

  imgs <- str_extract(imgs.wTraining, "m_[0-9]{7}_.*_[0-9]{8}") %>% na.omit() %>% unique()

  lapply(imgs, function(img) {

      train.imgs <- list.files(f.dir, paste0(img, "_masked.*.tif$"), full.names = T)

      train.imgs <- lapply(train.imgs, raster)

      train.imgs <- lapply(train.imgs, function(r) {
          cover <- str_extract(names(r), "(livetrees|liveveg|other|snag)")
          cells <- which(getValues(r > 0))
          df <- data.frame(cell = cells, Class = cover, stringsAsFactors = F)
      })

      ext_ID <- do.call("bind", train.imgs)

      f <- list.files(paste0(f.dir, img), full.names = T, pattern = "masked_[0-9]+_.*.tif$")

      train.stack <- stack(f)

      fn <- paste0(f.dir,img, ".ffdata")

      mat <- ff(vmode="integer",dim=c(ncell(train.stack),nlayers(train.stack)),filename=fn)
                                          #
                                          #
                                          #
                                          #
  ### if data is too big for ff, need fewer layers or smaller training images!!! argggggg!!!

      for(i in 1:nlayers(train.stack)){
          mat[,i] <- train.stack[[i]][]
      }

      save(mat,file=paste0(f.dir,img, "_train.RData"))

      extracted.values <- mat[ext_ID$cell,]

      df <- data.frame(extracted.values)
      colnames(df) <- names(train.stack)

      df$Class <- factor(ext_ID$Class)

      saveRDS(df, paste0(f.dir,img, "_model_building_df.rds"))
  })


  dfs <- list.files(f.dir, pattern = paste0(".*","_model_building_df.rds"), full.names = T, recursive = T)

  dfs <- lapply(dfs, readRDS)

  for(i in 1:length(dfs)) {
      colnames(dfs[[i]])[1:(length(colnames(dfs[[i]]))-1)] <- str_match(colnames(dfs[[i]]), "^(masked_[0-9]+_)(.*)")[,3][1:(length(colnames(dfs[[i]]))-1)]
  }

  df <- do.call("rbind", dfs)

  df <- df %>% na.omit()
  mod <- randomForest(y = factor(df$Class), x= df[,1:(dim(df)[2]-1)])

  saveRDS(mod, paste0(f.dir, "mod.rds"))

#+end_src

